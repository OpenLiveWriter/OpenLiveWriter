using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using OpenLiveWriter.Extensibility.BlogClient;
using YamlDotNet.RepresentationModel;
using YamlDotNet.Serialization;

namespace OpenLiveWriter.BlogClient.Clients
{
    public class GitHubPage
    {
        public string url { get; set; }
        public string status { get; set; }
        public string cname { get; set; }
        public bool custom_404 { get; set; }
    }

    public class GitHubRepository
    {
        public int id { get; set; }
        public string name { get; set; }
        public string full_name { get; set; }
        public Owner owner { get; set; }
        public string html_url { get; set; }
        public string git_url { get; set; }
        public string ssh_url { get; set; }
        public string clone_url { get; set; }
        public object homepage { get; set; }
        public bool has_pages { get; set; }
        public string default_branch { get; set; }
    }

    public class Owner
    {
        public int id { get; set; }
        public string avatar_url { get; set; }
        public string url { get; set; }
        public string html_url { get; set; }
        public bool site_admin { get; set; }
    }

    internal class GitHubEntry
    {
        public string name { get; set; }
        public string path { get; set; }
        public string sha { get; set; }
        public int size { get; set; }
        public string url { get; set; }
        public string html_url { get; set; }
        public string git_url { get; set; }
        public string download_url { get; set; }
        public string type { get; set; }
        public string content { get; set; }
        public string encoding { get; set; }
        public _Links _links { get; set; }

        public class _Links
        {
            public string self { get; set; }
            public string git { get; set; }
            public string html { get; set; }
        }

    }

    /// <summary>
    /// http://jekyllrb.com/docs/frontmatter/
    /// </summary>
    public class PageMetadata
    {
        // Predefined Global Variables
        public string layout;
        public string permalink;
        public bool published;
        public string category;
        public List<string> categories;
        public List<string> tags;
        // Excerpt/excerpt_separator is generated by Jekyll itself, but it can be overrided in YFM.
        public string excerpt;
        public string excerpt_separator;
        // Predefined Variables for Posts
        public DateTime date;
        // User defined dynamic variables
        public YamlStream userDefinedMetadata;
        private string userDefinedMetadataRaw;

        public PageMetadata()
        {

        }

        public PageMetadata(BlogPost post)
        {
            this.layout = post.Layout;
            this.permalink = post.Permalink;
            this.excerpt = post.Excerpt;
            if (post.Categories != null)
            {
                this.categories = post.Categories.Select(o => o.Name).ToList();
            }

            if (!String.IsNullOrEmpty(post.Keywords))
            {
                this.tags = post.Keywords.Split(',').ToList();
            }

            userDefinedMetadataRaw = post.FrontMatter;
        }

        public PageMetadata(YamlMappingNode rootNode)
        {
            var userMetadataRootNode = new YamlMappingNode();
            this.userDefinedMetadata = new YamlStream(new YamlDocument(userMetadataRootNode));

            this.categories = new List<string>();
            this.tags = new List<string>();
            if (rootNode != null)
            {
                foreach (var entry in rootNode.Children)
                {
                    var node = entry.Key as YamlScalarNode;
                    if (node == null)
                    {
                        continue;
                    }

                    switch (node.Value)
                    {
                        case "layout" : 
                            layout = entry.Value.ToString();
                            break;
                        case "permalink":
                            permalink = entry.Value.ToString();
                            break;
                        case "published":
                            bool valueBool;
                            if (bool.TryParse(entry.Value.ToString(), out valueBool))
                            {
                                published = valueBool;
                            }
                            else
                            {
                                published = false;
                            }
                            break;
                        case "excerpt":
                            this.excerpt = entry.Value.ToString();
                            break;
                        case "category":
                            this.category = entry.Value.ToString();
                            break;
                        case "categories":
                            var categoryNode = entry.Value as YamlScalarNode;
                            if (categoryNode != null)
                            {
                                var trySplitCategory = Regex.Split(entry.Value.ToString(), @"\s+");
                                if (trySplitCategory.Length > 1)
                                {
                                    this.categories.AddRange(trySplitCategory);
                                }
                                else {
                                    this.category = entry.Value.ToString();
                                }
                                break;
                            }
                            var categoriesNode = entry.Value as YamlSequenceNode;
                            this.categories.AddRange(categoriesNode.SelectMany(o => Regex.Split(o.ToString(), @"\s+")));
                            break;
                        case "tags":
                            var tagsNode = (YamlSequenceNode)entry.Value;
                            this.tags.AddRange(tagsNode.Select(o => o.ToString()));
                            break;
                        default:
                            userMetadataRootNode.Add(node.Value, entry.Value);
                            break;
                    }

                }
            }
        }

        public string UserDefinedMetadata
        {
            get
            {
                if(! ((YamlMappingNode)userDefinedMetadata.Documents[0].RootNode).Children.Any() )
                {
                    return String.Empty;
                }

                var sb = new StringBuilder();
                userDefinedMetadata.Save(new StringWriter(sb));
                var result = sb.ToString().TrimEnd(new[] { '\n', '\r' });

                if (result.Length < 3)
                {
                    return result;
                }
                else
                {
                    // Only when using YamlDotnet Serialize, the document output will end implicitly.
                    // As we are using YamlStream.Save() here, let's remove Indicator `...` manually.
                    return result.Substring(0, result.Length - 3);
                }
            }
        }

        public string Yaml
        {
            get
            {
                var serializer = new Serializer();
                var sw = new StringWriter();

                if (!String.IsNullOrEmpty(this.layout))
                {
                    serializer.Serialize(sw, new { this.layout });
                }

                if (!String.IsNullOrEmpty(this.permalink))
                {
                    serializer.Serialize(sw, new { this.permalink });
                }

                if (!String.IsNullOrEmpty(this.excerpt))
                {
                    serializer.Serialize(sw, new { this.excerpt });
                }

                if (this.categories.Any())
                {
                    serializer.Serialize(sw, new { categories = this.categories.ToArray() });
                }

                if (this.tags.Any())
                {
                    serializer.Serialize(sw, new { tags = this.tags.ToArray() });
                }

                sw.WriteLine(userDefinedMetadataRaw);
                return sw.ToString();
            }
        }
    }
    public static class StringExtension
    {
        public static Regex yfm = new Regex(@"(?s:^---(.*?)---)");
        public static PageMetadata YamlFrontMatter(this string text)
        {
            var matches = yfm.Matches(text);
            if (matches.Count == 0)
            {
                return default(PageMetadata);
            }

            var yaml = new YamlStream();
            yaml.Load(new StringReader(matches[0].Groups[1].Value));
            return new PageMetadata( (YamlMappingNode)yaml.Documents[0].RootNode );
        }

        public static string MarkdownContent(this string text)
        {
            var matches = yfm.Matches(text);
            if (matches.Count == 0)
            {
                return text;
            }

            return text.Replace(matches[0].Groups[0].Value, String.Empty)
                .TrimStart(Environment.NewLine.ToCharArray())
                .TrimEnd(Environment.NewLine.ToCharArray());
        }
    }
}
